Phase-1:
- Introduction to Enterprise Application Development
  - Monolithic vs Microservice Architecture
  - Scalibility, Performance of applications
  - MERN
  - Microservice Architecture
  - Break down application

Phase-2:
- Node JS
  - Creating Server and API
  - Understand Event-driven and non-blocking I/O
- RESTful APIs
  - Routes, Request Handling, Middlewares
  - Authentication (JWT)
  - Role-Based Access
- Microservice Design
  - Breaking down application into smaller services
  - Communication b/w Microservices 
  - Handling inter-service communication
- Service Discover & Load Balancing

Phase-3:
- Build Frontend for Microservices
- Make API request
- Data management and caching

Phase-4:
- Docker
- Docker Compose
- Docker Networking & Volumes

Phase-5:
- Version Control
- CI/CD using GitHub Action/GitLab
- Container Orchestration with Kubernetes


Monolithic Architecture
- Entire application is built using as a single codebase
- Tightly coupling: Components are tightly coupled, which means changes in one module will effect other modules
Single database: Typically uses single database


Microservices Architecture
- Divides the application into small and independent services that communicates over APIs
- Each microservice focuses on a single business functionality and responsible for managings its own data
- Multiple services
- Independent Development/Depolyment
- Loose coupling
- Multiple Databases

Required dependencies
- npm install express mongoose bcrypt dotenv cors


============================
docker build -t user-img .
docker run -v "$(pwd)":/app -d -p 1234:1234 --name user-auth-container user-img
============================
docker-compose up -d

============================

RabbitMQ
- it's a message broker
- allows different parts of a system (microservice) to communicate with each other asynchronously by sending and receiving messages through queues

- Services don't need to call each other directly.
- They just send messages to RabbitMQ, and RabbitMQ ensures that the messages are delivered to the appropriate services.

Message: Piece of data sent from one service to another (JSON, string, number)
Publisher: Service that sends the message to RabbitMQ
Consumer: Service that receives the message from RabbitMQ
Queue: Storage area where messages are stored until they are processed by the consumer
Exchange: Routing mechanism that decides which queues receives the message

============================

In our case:
- Order service needs to notify multiple services when an order is placed
User Service: send confirmation email to user, update user order history
Product Service: update stock

How we are going to use ?
Order Service (Publisher): publish order info to RabbitMQ
User Service (Consumer): listen to order queue, process order info, sends email
Product Service (Consumer): listen to order queue, process order info, update stock

============================

npm install amqplib

userId: "68c19d8f057d4179bd5e3abe"
productId: "68c19e8d24f1f4b9d9a30629"

============================

Problem with one queue (orderQueue)
- Both userService and productService were consuming from that one queue only
- RabbitMQ sends the message in round-robin fashion to multiple consumers on same queue
- One message - only one consumer

Solution is to create Exchange:
- Exchange is like a Router in RabbitMQ
- We pass one argument inside Exchange: fanout
  - Send every message to all bound queues

============================

TODO:
- Once order service is up and running successfully:
  - check first if user is already logged In
  - send confirmation mail to user about order success or failure

============================

Logging
- used for debugging and monitoring the application

1. Centralized Logging: All microservices send their logs to a central system so we can search and analyze them easily in one place
2. Structured Logging: Use JSON format for logs instead of plain text
3. Log Levels: Different levels of logs (info, warn, error, debug)
4. Persistent Storage: Logs should be stored for later analysis
5. Log Rotation: Automatically delete old logs to save space

Implementation in Node JS
1. Winston: A popular logging library for Node.js
2. Morgan: HTTP request logger middleware for Node.js
3. Bunyan: Great for JSON logging
4. Pino: Fast and low-overhead logging library for Node.js

============================

npm install winston winston-daily-rotate-file

{
  "timestamp": "2024-10-01T12:00:00Z",
  "level": "info",
  "message": "User created successfully",
  "service": "user-service",
  "requestId": "123e4567-e89b-12d3-a456-426614174000"
  "orderId": "987e6543-e21b-12d3-a456-426614174000"
}

============================

Redis DB
- In-memory data structure store, used as a database, cache, and message broker

Features:
1. Caching
 - Frequently access data
   - Store results of DB queries, API calls and other computations
  - Reduce latency and improve performance
  - faster response time
  - Scalibility
2. Session Management
  - Store user session data
  - JWT Token blacklisting
3. Rate Limiting/throttling
  - Limit number of requests a user can make to an API within a certain time period
  - Prevent abuse and ensure fair usage
4. Pub/Sub Messaging
  - Implement real-time messaging and notifications
5. Leaderboards and Counting
  - Real-time leaderboards, counters, and analytics

Alternatives to Redis
1. Memcached
2. Apache Ignite
3. Hazelcast
4. Amazon ElastiCache
5. Aerospike
